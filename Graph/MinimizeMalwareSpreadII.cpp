/*
 * In a network of nodes, each node i is directly connected to another node j if
 * and only if graph[i][j] = 1.
 *
 * Some nodes initial are initially infected by malware. Whenever two nodes are
 * directly connected and at least one of those nodes is infected by malware,
 * both nodes will infected by malware. This spread of malware will continue
 * until no more nodes can be infected in this manner.
 *
 * Supose M(initial) is the final number of nodes infected with malware in the
 * entire network, after the spread of malware stops.
 *
 * We will remove one node from the initial list, completely removing it and any
 * connections from this node to any other node. Return the node that if
 * removed, would minimize M(initial). If multiple ndoes could be removed to
 * minimize M(initial), return such a node with the smallest index.
 *
 * Date: 06/26/2020
 * Author: Wei Du
 */

#include <numeric>
#include <queue>
#include <vector>
using namespace std;

class Solution {
public:
    int minMalwareSpread(vector<vector<int>> &graph, vector<int> &initial) {
        numVert = graph.size();
        for (int i = 0; i < numVert; ++i)
            for (int j = 0; j < numVert; ++j)
                if (graph[i][j]) edges[i].push_back(j);
        int sourceIdx{-1};
        int maxAffected{300};

        // do bfs;
        queue<int> q;
        std::sort(initial.begin(), initial.end());
        for (int i = 0; i < initial.size(); ++i) {
            std::fill(visited, visited + 300, false);
            for (int s : initial) {
                visited[s] = true;
                if (s != initial[i]) q.push(s);
            }
            int cnt = q.size();
            while (!q.empty()) {
                int tmp{q.front()};
                q.pop();
                for (int neigb : edges[tmp]) {
                    if (!visited[neigb]) {
                        visited[neigb] = true;
                        q.push(neigb);
                        ++cnt;
                    }
                }
            }
            if (maxAffected > cnt) {
                maxAffected = cnt;
                sourceIdx = initial[i];
            }
        }
        return sourceIdx;
    }

private:
    int numVert;
    vector<int> edges[300];
    bool visited[300];
};
